<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>NSG_SpatialReferenceSystemsTests.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">NSG GeoPackage 1.1 Conformance Test Suite</a> &gt; <a href="index.source.html" class="el_package">org.opengis.cite.gpkg12.nsg.core</a> &gt; <span class="el_source">NSG_SpatialReferenceSystemsTests.java</span></div><h1>NSG_SpatialReferenceSystemsTests.java</h1><pre class="source lang-java linenums">package org.opengis.cite.gpkg12.nsg.core;

import static org.testng.Assert.assertTrue;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.geotools.referencing.CRS;
import org.opengis.cite.gpkg12.CommonFixture;
import org.opengis.cite.gpkg12.ErrorMessage;
import org.opengis.cite.gpkg12.ErrorMessageKeys;
import org.opengis.cite.gpkg12.nsg.util.NSG_XMLUtils;
import org.opengis.cite.gpkg12.util.DatabaseUtility;
import org.opengis.referencing.FactoryException;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.testng.Assert;
import org.testng.SkipException;
import org.testng.annotations.Test;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

<span class="fc" id="L43">public class NSG_SpatialReferenceSystemsTests extends CommonFixture {</span>

<span class="fc" id="L45">    private final static Logger LOG = Logger.getLogger( NSG_SpatialReferenceSystemsTests.class.getName() );</span>

    private static final String NSG_CRS_LISTING = &quot;NSG_CRS_WKT.xml&quot;;

    private static final String ANNEX_C_3395_TABLE = &quot;Annex_C_3395_Table.txt&quot;;

    private static final String ANNEX_E_4326_TABLE = &quot;Annex_E_4326_Table.txt&quot;;

    private static final double TOLERANCE = 1.0e-10;

    /**
     * NSG Req 3: The CRSs listed in Table 4, Table 5, and Table 6 SHALL be the only CRSs used by raster tile pyramid
     * and vector feature data tables in a GeoPackage.
     *
     * @throws SQLException
     *             if access to gpkg failed
     */
    @Test(groups = { &quot;NSG&quot; }, description = &quot;NSG Req 3 (identified CRSs)&quot;)
    public void crsTest()
                            throws SQLException {
<span class="nc" id="L65">        NodeList crsList = openCrsListing();</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">        assertTrue( crsList != null,</span>
<span class="nc" id="L67">                    ErrorMessage.format( ErrorMessageKeys.UNDEFINED_SRS, &quot; - no designated CRS Lookup Table&quot; ) );</span>

<span class="nc bnc" id="L69" title="All 2 branches missed.">        if ( crsList != null ) {</span>
<span class="nc" id="L70">            String queryStr = &quot;SELECT srs_id, organization_coordsys_id FROM gpkg_spatial_ref_sys&quot;;</span>

<span class="nc" id="L72">            try (final Statement statement = this.databaseConnection.createStatement();</span>
<span class="nc" id="L73">                                    final ResultSet resultSet = statement.executeQuery( queryStr )) {</span>
<span class="nc" id="L74">                final Collection&lt;String&gt; invalidSrsIds = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L75">                final Collection&lt;String&gt; invalidOrgIds = new LinkedList&lt;&gt;();</span>

<span class="nc bnc" id="L77" title="All 2 branches missed.">                while ( resultSet.next() ) {</span>
<span class="nc" id="L78">                    String srsID = resultSet.getString( &quot;srs_id&quot; ).trim();</span>
<span class="nc" id="L79">                    String orgID = resultSet.getString( &quot;organization_coordsys_id&quot; ).trim();</span>

<span class="nc bnc" id="L81" title="All 4 branches missed.">                    if ( srsID.equals( &quot;0&quot; ) || orgID.equals( &quot;0&quot; ) ) {</span>
<span class="nc" id="L82">                        continue;</span>
                    }
<span class="nc bnc" id="L84" title="All 4 branches missed.">                    if ( srsID.equals( &quot;-1&quot; ) || orgID.equals( &quot;-1&quot; ) ) {</span>
<span class="nc" id="L85">                        continue;</span>
                    }

<span class="nc" id="L88">                    Element element = NSG_XMLUtils.getElementByTextValue( crsList, &quot;srs_id&quot;, srsID );</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">                    if ( element == null ) {</span>
<span class="nc" id="L90">                        invalidSrsIds.add( srsID );</span>
                    } else {
<span class="nc" id="L92">                        String crsOrgID = NSG_XMLUtils.getXMLElementTextValue( element, &quot;organization_coordsys_id&quot; ).trim();</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">                        if ( !crsOrgID.equals( orgID ) ) {</span>
<span class="nc" id="L94">                            invalidOrgIds.add( orgID );</span>
                        }
                    }
<span class="nc" id="L97">                }</span>
<span class="nc" id="L98">                resultSet.close();</span>
<span class="nc" id="L99">                statement.close();</span>

<span class="nc" id="L101">                assertTrue( invalidSrsIds.isEmpty(),</span>
<span class="nc" id="L102">                            MessageFormat.format( &quot;The gpkg_spatial_ref_sys table contains invalid srs_id values {0}&quot;,</span>
<span class="nc" id="L103">                                                  invalidSrsIds.stream().map( Object::toString ).collect( Collectors.joining( &quot;, &quot; ) ) ) );</span>
<span class="nc" id="L104">                assertTrue( invalidOrgIds.isEmpty(),</span>
<span class="nc" id="L105">                            MessageFormat.format( &quot;The gpkg_spatial_ref_sys table contains invalid organization_coordsys_id values {0}&quot;,</span>
<span class="nc" id="L106">                                                  invalidOrgIds.stream().map( Object::toString ).collect( Collectors.joining( &quot;, &quot; ) ) ) );</span>
<span class="nc bnc" id="L107" title="All 16 branches missed.">            }</span>
        }
<span class="nc" id="L109">    }</span>

    /**
     * @throws SQLException
     *             if access to gpkg failed
     */
    @Test(groups = { &quot;NSG&quot; }, description = &quot;NSG Req 4 &amp; 5 (match Annex table)&quot;)
    public void matchAnnexTableTest()
                            throws SQLException {
        // --- original intent was to implement here; but may make more sense to
        // implement in NSG_TileTests
<span class="nc" id="L120">        final Collection&lt;String&gt; invalidMatrixEntries = new LinkedList&lt;&gt;();</span>

        // In the case there is no gpkg_tile_matrix ... say this geopackage has no tiles, skip this test
<span class="nc" id="L123">        final boolean hasTileMatrixTable = DatabaseUtility.doesTableOrViewExist(this.databaseConnection, &quot;gpkg_tile_matrix&quot;);</span>
        
<span class="nc bnc" id="L125" title="All 2 branches missed.">        if (hasTileMatrixTable) {</span>
        
<span class="nc" id="L127">	        String queryStr = &quot;SELECT tm.table_name AS tabName, sel.data_type AS dataTyp, sel.crs_id AS crsID, tm.zoom_level AS zoomLvl, tm.matrix_width AS matrixW, tm.matrix_height AS matrixH, tm.tile_width AS tileW, tm.tile_height AS tileH, tm.pixel_x_size AS pixelSzX, tm.pixel_y_size AS pixelSzY &quot;</span>
	                          + &quot;FROM gpkg_tile_matrix tm &quot;
	                          + &quot;INNER JOIN (SELECT gc.table_name, gc.data_type, gs.organization_coordsys_id as crs_id  from gpkg_contents gc inner join gpkg_spatial_ref_sys gs where gc.srs_id=gs.srs_id) AS sel &quot;
	                          + &quot;ON tm.table_name=sel.table_name &quot; + &quot;WHERE crsID IN (3395, 4326) ORDER BY zoomLvl;&quot;;
	
<span class="nc" id="L132">	        try (final Statement statement = this.databaseConnection.createStatement();</span>
<span class="nc" id="L133">	                                final ResultSet resultSet = statement.executeQuery( queryStr )) {</span>
<span class="nc" id="L134">	            List&lt;Object[]&gt; annexC_3395 = populateAnnex( ANNEX_C_3395_TABLE, &quot;Annex C (EPSG:3395)&quot; );</span>
<span class="nc" id="L135">	            List&lt;Object[]&gt; annexE_4326 = populateAnnex( ANNEX_E_4326_TABLE, &quot;Annex E (EPSG:4326)&quot; );</span>
	
<span class="nc bnc" id="L137" title="All 2 branches missed.">	            while ( resultSet.next() ) {</span>
<span class="nc" id="L138">	                String tabNam = resultSet.getString( &quot;tabName&quot; ).trim();</span>
<span class="nc" id="L139">	                String srsID = resultSet.getString( &quot;crsID&quot; ).trim();</span>
<span class="nc" id="L140">	                int zoomLvl = resultSet.getInt( &quot;zoomLvl&quot; );</span>
	
<span class="nc" id="L142">	                long matrixW = resultSet.getLong( &quot;matrixW&quot; );</span>
<span class="nc" id="L143">	                long matrixH = resultSet.getLong( &quot;matrixH&quot; );</span>
<span class="nc" id="L144">	                double pixelSzX = resultSet.getDouble( &quot;pixelSzX&quot; );</span>
<span class="nc" id="L145">	                double pixelSzY = resultSet.getDouble( &quot;pixelSzY&quot; );</span>
	
<span class="nc" id="L147">	                List&lt;Object[]&gt; annexTable = selectAnnexBySrsId( srsID, annexC_3395, annexE_4326 );</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">	                for ( Object[] obj : annexTable ) {</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">	                    if ( zoomLvl == (int) obj[0] ) {</span>
<span class="nc" id="L150">	                        long imW = (long) obj[3];</span>
<span class="nc" id="L151">	                        long imH = (long) obj[4];</span>
<span class="nc" id="L152">	                        double pX = (double) obj[2];</span>
<span class="nc" id="L153">	                        double pY = (double) obj[2];</span>
	
<span class="nc bnc" id="L155" title="All 2 branches missed.">	                        if ( Math.abs( pX - pixelSzX ) &gt; TOLERANCE ) {</span>
<span class="nc" id="L156">	                            invalidMatrixEntries.add( tabNam + &quot; (&quot; + srsID + &quot;, Zoom Level: &quot; + zoomLvl + &quot;): &quot;</span>
	                                                      + &quot;Pixel Size X: &quot; + pixelSzX + &quot;; but expected &quot; + pX );
<span class="nc bnc" id="L158" title="All 2 branches missed.">	                        } else if ( Math.abs( pY - pixelSzY ) &gt; TOLERANCE ) {</span>
<span class="nc" id="L159">	                            invalidMatrixEntries.add( tabNam + &quot; (&quot; + srsID + &quot;, Zoom Level: &quot; + zoomLvl + &quot;): &quot;</span>
	                                                      + &quot;Pixel Size Y: &quot; + pixelSzY + &quot;; but expected &quot; + pY );
<span class="nc bnc" id="L161" title="All 2 branches missed.">	                        } else if ( imW != matrixW ) {</span>
<span class="nc" id="L162">	                            invalidMatrixEntries.add( tabNam + &quot; (&quot; + srsID + &quot;, Zoom Level: &quot; + zoomLvl + &quot;): &quot;</span>
	                                                      + &quot;Matrix Width: &quot; + matrixW + &quot;; but expected &quot; + imW );
<span class="nc bnc" id="L164" title="All 2 branches missed.">	                        } else if ( imH != matrixH ) {</span>
<span class="nc" id="L165">	                            invalidMatrixEntries.add( tabNam + &quot; (&quot; + srsID + &quot;, Zoom Level: &quot; + zoomLvl + &quot;): &quot;</span>
	                                                      + &quot;Matrix Height: &quot; + matrixH + &quot;; but expected &quot; + imH );
	                        }
	                    }
<span class="nc" id="L169">	                }</span>
<span class="nc" id="L170">	            }</span>
<span class="nc" id="L171">	            assertTrue( invalidMatrixEntries.isEmpty(),</span>
<span class="nc" id="L172">	                        MessageFormat.format( &quot;The gpkg_tile_matrix table contains invalid Pixels Size or Matrix Size values for tables: {0}&quot;,</span>
<span class="nc" id="L173">	                                              invalidMatrixEntries.stream().map( Object::toString ).collect( Collectors.joining( &quot;, &quot; ) ) ) );</span>
<span class="nc bnc" id="L174" title="All 16 branches missed.">	        }</span>
        }
<span class="nc" id="L176">    }</span>

    /*
     * TODO: Implement Test for Requirement 6
     * 
     * --- NSG Req 6: The WGS 84 Geographic 2D CRS SHALL be used for 2D vector features. WGS 84 Geographic 2D
     * GeoPackages SHALL follow the technical guidance provided in Annex E: Implementation Guide for EPSG::4326 Tiles.
     * 
     * @Test(groups = { &quot;NSG&quot; }, description = &quot;NSG Req 6 (match Annex table)&quot;)
     */

    /**
     * NSG Req 8: The CRS definitions in Table 7 through Table 19 below SHALL be used to specify the CRS used for tiles
     * and vector feature user data tables containing NSG data in a GeoPackage.
     *
     * NSG Req 9: Other CRS definitions SHALL NOT be specified for GeoPackage SQL tables containing NSG data.
     *
     * @throws SQLException
     *             if access to gpkg failed
     */
    @Test(groups = { &quot;NSG&quot; }, description = &quot;NSG Req 8 &amp; 9 (CRS definitions)&quot;)
    public void crsDefinitionsTest()
                            throws SQLException {
<span class="nc" id="L199">        NodeList crsList = openCrsListing();</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">        assertTrue( crsList != null,</span>
<span class="nc" id="L201">                    ErrorMessage.format( ErrorMessageKeys.UNDEFINED_SRS, &quot; - no designated CRS Lookup Table&quot; ) );</span>

<span class="nc bnc" id="L203" title="All 2 branches missed.">        if ( crsList != null ) {</span>
<span class="nc" id="L204">            String queryStr = &quot;SELECT srs_id,definition FROM gpkg_spatial_ref_sys&quot;;</span>

<span class="nc" id="L206">            try (final Statement statement = this.databaseConnection.createStatement();</span>
<span class="nc" id="L207">                                    final ResultSet resultSet = statement.executeQuery( queryStr )) {</span>
<span class="nc" id="L208">                final Collection&lt;String&gt; invalidSrsDefs = new LinkedList&lt;&gt;();</span>

<span class="nc bnc" id="L210" title="All 2 branches missed.">                while ( resultSet.next() ) {</span>
<span class="nc" id="L211">                    String srsID = resultSet.getString( &quot;srs_id&quot; ).trim();</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">                    if ( srsID.equals( &quot;0&quot; ) ) {</span>
<span class="nc" id="L213">                        continue;</span>
                    }
<span class="nc bnc" id="L215" title="All 2 branches missed.">                    if ( srsID.equals( &quot;-1&quot; ) ) {</span>
<span class="nc" id="L216">                        continue;</span>
                    }

<span class="nc" id="L219">                    String srsDef = resultSet.getString( &quot;definition&quot; ).trim().replaceAll( &quot;\\s+&quot;, &quot;&quot; );</span>

<span class="nc" id="L221">                    Element element = NSG_XMLUtils.getElementByTextValue( crsList, &quot;srs_id&quot;, srsID );</span>
<span class="nc" id="L222">                    String crsDef = NSG_XMLUtils.getXMLElementTextValue( element, &quot;definition&quot; ).trim().replaceAll( &quot;\\s+&quot;, &quot;&quot; );</span>
<span class="nc" id="L223">                    boolean found = crsDef.equalsIgnoreCase( srsDef );</span>
                    
<span class="nc" id="L225">                    String code = &quot;&quot;;</span>
<span class="nc bnc" id="L226" title="All 4 branches missed.">                    if ( element != null &amp;&amp; !found) {</span>
                    	try {
	                        try {
	                        	// This call consistently fails with: org.geotoolkit.referencing.factory.ReferencingObjectFactory cannot be cast to org.opengis.referencing.Factory
<span class="nc" id="L230">	                            CoordinateReferenceSystem example = CRS.parseWKT( srsDef );</span>
	
	                            
<span class="nc" id="L233">	                            code = CRS.lookupIdentifier( example, true );</span>
<span class="nc" id="L234">	                        } catch (FactoryException e) {</span>
<span class="nc" id="L235">	                            invalidSrsDefs.add( srsID + &quot;:&quot; + srsDef + &quot; : &quot; + e.getMessage() );</span>
<span class="nc" id="L236">	                            Assert.fail( MessageFormat.format( &quot;The gpkg_spatial_ref_sys table error srs_id, wkt, error: {0}&quot;,</span>
<span class="nc" id="L237">	                                                               invalidSrsDefs.stream().map( Object::toString ).collect( Collectors.joining( &quot;, &quot; ) ) ) );</span>
<span class="nc" id="L238">	                        }</span>
	                        try {
<span class="nc" id="L240">	                            CoordinateReferenceSystem  decodedcrs = CRS.decode( code );</span>
<span class="nc" id="L241">	                        } catch ( FactoryException e ) {</span>
<span class="nc" id="L242">	                            invalidSrsDefs.add( srsID + &quot;:&quot; + srsDef + &quot;: &quot; + code + &quot;:&quot; + e.getMessage());</span>
<span class="nc" id="L243">	                            Assert.fail( MessageFormat.format( &quot;The gpkg_spatial_ref_sys table contains invalid CRS defintions values for IDs {0}&quot;,</span>
<span class="nc" id="L244">	                                                               invalidSrsDefs.stream().map( Object::toString ).collect( Collectors.joining( &quot;, &quot; ) ) ) );</span>
<span class="nc" id="L245">	                        }</span>
<span class="nc" id="L246">                    	} catch (Exception ex) {   // The exectpin is consistently being caught from the CRS.parseWKT fails with: org.geotoolkit.referencing.factory.ReferencingObjectFactory cannot be cast to org.opengis.referencing.Factory</span>
<span class="nc" id="L247">                    		invalidSrsDefs.add( srsID + &quot;:&quot; + srsDef + &quot; : &quot; + ex.getMessage() );</span>
<span class="nc" id="L248">                    		LOG.log( Level.WARNING, &quot;The gpkg_spatial_ref_sys table could not be examined for IDs due to processing exception.&quot;, invalidSrsDefs.stream().map( Object::toString ).collect( Collectors.joining( &quot;, &quot; ) ) );</span>
                        	//Assert.fail( MessageFormat.format( &quot;The gpkg_spatial_ref_sys table could not be examined for IDs due to processing exception {0}&quot;,
                            //    invalidSrsDefs.stream().map( Object::toString ).collect( Collectors.joining( &quot;, &quot; ) ) ) );
<span class="nc" id="L251">                    	}</span>
                    }
<span class="nc" id="L253">                }</span>
<span class="nc bnc" id="L254" title="All 16 branches missed.">            }</span>
        }
<span class="nc" id="L256">    }</span>

    /**
     * NSG Req 19: Data validity SHALL be assessed against data value constraints specified in Table 26 below using a
     * test suite. Data validity MAY be enforced by SQL triggers.
     *
     * 19-A: Addresses Table 26 Rows 1-2 (regarding table &quot;gpkg_spatial_ref_sys&quot;)
     *
     * @throws SQLException
     *             if access to gpkg failed
     */
    @Test(groups = { &quot;NSG&quot; }, description = &quot;NSG Req 19-A (Data Validity: gpkg_spatial_ref_sys)&quot;)
    public void dataValidity_gpkg_spatial_ref_sys()
                            throws SQLException {
<span class="nc" id="L270">        NodeList crsList = openCrsListing();</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">        assertTrue( crsList != null,</span>
<span class="nc" id="L272">                    ErrorMessage.format( ErrorMessageKeys.UNDEFINED_SRS, &quot; - no designated CRS Lookup Table&quot; ) );</span>

<span class="nc bnc" id="L274" title="All 2 branches missed.">        if ( crsList != null ) {</span>
<span class="nc" id="L275">            String queryStr = &quot;SELECT srs_id,organization,description FROM gpkg_spatial_ref_sys;&quot;;</span>

<span class="nc" id="L277">            try (final Statement statement = this.databaseConnection.createStatement();</span>
<span class="nc" id="L278">                                    final ResultSet resultSet = statement.executeQuery( queryStr )) {</span>
<span class="nc" id="L279">                final Collection&lt;String&gt; invalidOrgs = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L280">                final Collection&lt;String&gt; invalidDesc = new LinkedList&lt;&gt;();</span>

<span class="nc bnc" id="L282" title="All 2 branches missed.">                while ( resultSet.next() ) {</span>
<span class="nc" id="L283">                    String srsID = resultSet.getString( &quot;srs_id&quot; ).trim();</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">                    if ( srsID.equals( &quot;0&quot; ) ) {</span>
<span class="nc" id="L285">                        continue;</span>
                    }
<span class="nc bnc" id="L287" title="All 2 branches missed.">                    if ( srsID.equals( &quot;-1&quot; ) ) {</span>
<span class="nc" id="L288">                        continue;</span>
                    }

                    // --- test for: Table 26; Row 1

<span class="nc" id="L293">                    String srsOrg = resultSet.getString( &quot;organization&quot; ).trim().toUpperCase();</span>
<span class="nc bnc" id="L294" title="All 4 branches missed.">                    if ( !srsOrg.equals( &quot;EPSG&quot; ) &amp;&amp; !srsOrg.equals( &quot;NGA&quot; ) ) {</span>
<span class="nc" id="L295">                        invalidOrgs.add( srsID + &quot;:&quot; + srsOrg );</span>
                    }

                    // --- test for: Table 26; Row 2

<span class="nc" id="L300">                    String srsDesc = resultSet.getString( &quot;description&quot; );</span>

<span class="nc" id="L302">                    boolean found = false;</span>

<span class="nc" id="L304">                    Element element = NSG_XMLUtils.getElementByTextValue( crsList, &quot;srs_id&quot;, srsID );</span>
<span class="nc bnc" id="L305" title="All 4 branches missed.">                    if ( element != null &amp;&amp; srsDesc != null ) {</span>
<span class="nc" id="L306">                        srsDesc = srsDesc.trim();</span>
<span class="nc bnc" id="L307" title="All 4 branches missed.">                        if ( srsDesc.length() &gt; 0 &amp;&amp; ( !srsDesc.toUpperCase().equalsIgnoreCase( &quot;NULL&quot; ) )</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">                             &amp;&amp; ( !srsDesc.toUpperCase().equalsIgnoreCase( &quot;UNK&quot; ) )</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">                             &amp;&amp; ( !srsDesc.toUpperCase().equalsIgnoreCase( &quot;UNKNOWN&quot; ) )</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">                             &amp;&amp; ( !srsDesc.toUpperCase().equalsIgnoreCase( &quot;TBD&quot; ) ) ) {</span>
<span class="nc" id="L311">                            String crsDesc = NSG_XMLUtils.getXMLElementTextValue( element, &quot;description&quot; ).trim();</span>
<span class="nc" id="L312">                            found = crsDesc.equalsIgnoreCase( srsDesc );</span>
<span class="nc bnc" id="L313" title="All 6 branches missed.">                            if ( !found &amp;&amp; ( crsDesc.endsWith( &quot;.&quot; ) || srsDesc.endsWith( &quot;.&quot; ) ) ) {</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">                                if ( srsDesc.endsWith( &quot;.&quot; ) )</span>
<span class="nc" id="L315">                                    srsDesc = srsDesc.substring( 0, srsDesc.length() - 1 );</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">                                if ( crsDesc.endsWith( &quot;.&quot; ) )</span>
<span class="nc" id="L317">                                    crsDesc = crsDesc.substring( 0, crsDesc.length() - 1 );</span>
<span class="nc" id="L318">                                found = crsDesc.equalsIgnoreCase( srsDesc );</span>
                            }
                        }
                    }

<span class="nc bnc" id="L323" title="All 2 branches missed.">                    if ( !found ) {</span>
<span class="nc" id="L324">                        invalidDesc.add( srsID );</span>
                    }
<span class="nc" id="L326">                }</span>
<span class="nc" id="L327">                resultSet.close();</span>
<span class="nc" id="L328">                statement.close();</span>

<span class="nc" id="L330">                assertTrue( invalidOrgs.isEmpty(),</span>
<span class="nc" id="L331">                            MessageFormat.format( &quot;The gpkg_spatial_ref_sys table contains invalid organization values for IDs: {0}, should be \'EPSG\' or \'NGA\'&quot;,</span>
<span class="nc" id="L332">                                                  invalidOrgs.stream().map( Object::toString ).collect( Collectors.joining( &quot;, &quot; ) ) ) );</span>
<span class="nc" id="L333">                assertTrue( invalidDesc.isEmpty(),</span>
<span class="nc" id="L334">                            MessageFormat.format( &quot;The gpkg_spatial_ref_sys table contains invalid desciptions for IDs: {0}&quot;,</span>
<span class="nc" id="L335">                                                  invalidDesc.stream().map( Object::toString ).collect( Collectors.joining( &quot;, &quot; ) ) ) );</span>
<span class="nc bnc" id="L336" title="All 16 branches missed.">            }</span>
        }
<span class="nc" id="L338">    }</span>


    
    private List&lt;Object[]&gt; selectAnnexBySrsId( String srsID, List&lt;Object[]&gt; annexC_3395, List&lt;Object[]&gt; annexE_4326 ) {
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if ( srsID.equals( &quot;3395&quot; ) ) {</span>
<span class="nc" id="L344">            return annexC_3395;</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">        } else if ( srsID.equals( &quot;4326&quot; ) ) {</span>
<span class="nc" id="L346">            return annexE_4326;</span>
<span class="nc bnc" id="L347" title="All 4 branches missed.">        } else if ( ( srsID.equals( &quot;5041&quot; ) ) || ( srsID.equals( &quot;5042&quot; ) ) ) {</span>
<span class="nc" id="L348">            return Collections.emptyList();</span>
        }
<span class="nc" id="L350">        return Collections.emptyList();</span>
    }

    private List&lt;Object[]&gt; populateAnnex( String annexTableName, String annexName ) {
<span class="nc" id="L354">        InputStream resourceToRead = this.getClass().getResourceAsStream( annexTableName );</span>
<span class="nc" id="L355">        try (BufferedReader br = new BufferedReader( new InputStreamReader( resourceToRead, &quot;UTF-8&quot; ) )) {</span>
<span class="nc" id="L356">            List&lt;Object[]&gt; annexEntries = new ArrayList&lt;&gt;();</span>
            String line;
<span class="nc bnc" id="L358" title="All 2 branches missed.">            while ( ( line = br.readLine() ) != null ) {</span>
<span class="nc" id="L359">                List&lt;String&gt; items = Arrays.asList( line.split( &quot;\\s*,\\s*&quot; ) );</span>
<span class="nc bnc" id="L360" title="All 4 branches missed.">                if ( !items.isEmpty() &amp;&amp; ( items.size() == 5 ) ) {</span>
<span class="nc" id="L361">                    addNewEntry( annexEntries, items.get( 0 ), items.get( 1 ), items.get( 2 ), items.get( 3 ),</span>
<span class="nc" id="L362">                                 items.get( 4 ) );</span>
                } else {
<span class="nc" id="L364">                    throw new SkipException( annexName + &quot; Table is corrupt &quot; );</span>
                }
<span class="nc" id="L366">            }</span>
<span class="nc" id="L367">            return annexEntries;</span>
<span class="nc bnc" id="L368" title="All 8 branches missed.">        } catch ( IOException e ) {</span>
<span class="nc" id="L369">            throw new SkipException( annexName + &quot; Table not available&quot; );</span>
        }
    }
    

    private void addNewEntry( List&lt;Object[]&gt; table, String zoom, String scale, String pixelSz, String matrixWidth,
                              String matrixHeight ) {
<span class="nc" id="L376">        int zoomAsInt = Integer.parseInt( zoom );</span>
<span class="nc" id="L377">        double scaleAsDouble = Double.parseDouble( scale );</span>
<span class="nc" id="L378">        double pixelSizeAsDouble = Double.parseDouble( pixelSz );</span>
<span class="nc" id="L379">        long matrixWidthAsLong = Long.parseLong( matrixWidth );</span>
<span class="nc" id="L380">        long matrixHeightAsLong = Long.parseLong( matrixHeight );</span>
<span class="nc" id="L381">        Object[] row = { zoomAsInt, scaleAsDouble, pixelSizeAsDouble, matrixWidthAsLong, matrixHeightAsLong };</span>
<span class="nc" id="L382">        table.add( row );</span>
<span class="nc" id="L383">    }</span>

    private NodeList openCrsListing() {
<span class="nc" id="L386">        InputStream crsListing = this.getClass().getResourceAsStream( NSG_CRS_LISTING );</span>
<span class="nc" id="L387">        String rootName = &quot;Row&quot;;</span>
<span class="nc" id="L388">        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span>

        try {
<span class="nc" id="L391">            DocumentBuilder ioe = dbf.newDocumentBuilder();</span>
<span class="nc" id="L392">            Document dom = ioe.parse( crsListing );</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">            if ( dom != null ) {</span>
<span class="nc" id="L394">                Element docElems = dom.getDocumentElement();</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">                if ( docElems != null ) {</span>
<span class="nc" id="L396">                    return docElems.getElementsByTagName( rootName );</span>
                }
            }
<span class="nc" id="L399">        } catch ( ParserConfigurationException | SAXException | IOException e ) {</span>
<span class="nc" id="L400">            LOG.log( Level.SEVERE, &quot;Could not open CRS listing.&quot;, e );</span>
<span class="nc" id="L401">        }</span>

<span class="nc" id="L403">        return null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>